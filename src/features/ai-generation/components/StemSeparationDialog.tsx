import React, { useState, useEffect } from 'react';
import { Dialog, DialogContent, DialogHeader, DialogTitle } from '@/components/ui/dialog';
import { Button } from '@/components/ui/button';
import { Label } from '@/components/ui/label';
import { RadioGroup, RadioGroupItem } from '@/components/ui/radio-group';
import { Progress } from '@/components/ui/progress';
import { useToast } from '@/hooks/use-toast';
import { supabase } from '@/integrations/supabase/client';
import { Music2, Download, Play, Pause, Scissors, AudioWaveform } from 'lucide-react';
import { Badge } from '@/components/ui/badge';
import { Separator } from '@/components/ui/separator';

interface StemSeparationDialogProps {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  track: {
    id: string;
    title: string;
    audio_url?: string;
    metadata?: any;
  };
}

interface StemUrls {
  original?: string;
  vocals?: string;
  instrumental?: string;
  backingVocals?: string;
  drums?: string;
  bass?: string;
  guitar?: string;
  keyboard?: string;
  percussion?: string;
  strings?: string;
  synth?: string;
  fx?: string;
  brass?: string;
  woodwinds?: string;
}

interface SeparationMode {
  type: 'separate_vocal' | 'split_stem';
  label: string;
  description: string;
  stems: string[];
  credits: number;
}

const SEPARATION_MODES: SeparationMode[] = [
  {
    type: 'separate_vocal',
    label: 'Vocal Separation',
    description: 'Split into vocals and instrumental tracks',
    stems: ['Vocals', 'Instrumental'],
    credits: 1
  },
  {
    type: 'split_stem',
    label: 'Full Stem Separation',
    description: 'Split into up to 12 individual instrument tracks',
    stems: ['Vocals', 'Backing Vocals', 'Drums', 'Bass', 'Guitar', 'Keyboard', 'Strings', 'Brass', 'Woodwinds', 'Percussion', 'Synth', 'FX'],
    credits: 5
  }
];

export function StemSeparationDialog({ open, onOpenChange, track }: StemSeparationDialogProps) {
  const [separationType, setSeparationType] = useState<'separate_vocal' | 'split_stem'>('separate_vocal');
  const [isProcessing, setIsProcessing] = useState(false);
  const [progress, setProgress] = useState(0);
  const [stems, setStems] = useState<StemUrls | null>(null);
  const [taskId, setTaskId] = useState<string | null>(null);
  const [playingUrl, setPlayingUrl] = useState<string | null>(null);
  const [downloadingStems, setDownloadingStems] = useState<Set<string>>(new Set());
  const { toast } = useToast();

  // TODO: Fix Mureka integration
  const isSunoTrack = track.metadata?.service === 'suno';
  const isMurekaTrack = track.metadata?.service === 'mureka';

  useEffect(() => {
    if (!open) {
      // Reset state when dialog closes
      setStems(null);
      setTaskId(null);
      setProgress(0);
      setIsProcessing(false);
      setPlayingUrl(null);
      setDownloadingStems(new Set());
    }
  }, [open]);

  const handleStartSeparation = async () => {
    try {
      setIsProcessing(true);
      setProgress(10);

      if (isSunoTrack) {
        const sunoTaskId = track.metadata?.suno_task_id;
        const audioId = track.metadata?.suno_audio_id;

        if (!sunoTaskId || !audioId) {
          throw new Error('Suno track information not found. This feature only works with tracks generated by Suno.');
        }

        setProgress(20);

        const { data, error } = await supabase.functions.invoke('separate-suno-vocals', {
          body: {
            taskId: sunoTaskId,
            audioId,
            type: separationType
          }
        });

        if (error) throw error;

        setTaskId(data.taskId);
        setProgress(30);

        toast({
          title: "üéµ Separation started",
          description: `${separationType === 'separate_vocal' ? 'Vocal separation' : 'Full stem separation'} in progress...`
        });

        // Start polling for status
        pollSunoSeparationStatus(data.taskId);

      } else if (isMurekaTrack && track.audio_url) {
        // Use Mureka stem separation for Mureka tracks
        setProgress(20);

        const { data, error } = await supabase.functions.invoke('mureka-stem-separation', {
          body: {
            url: track.audio_url
          }
        });

        if (error) throw error;

        setProgress(50);
        setStems({
          original: track.audio_url,
          ...data.urls
        });
        setProgress(100);
        setIsProcessing(false);

        toast({
          title: "‚úÖ Stem separation completed",
          description: "All stems are ready for download"
        });

      } else {
        throw new Error('Stem separation is only available for Suno and Mureka tracks');
      }

    } catch (error: any) {
      console.error('Separation error:', error);
      toast({
        title: "‚ùå Separation failed",
        description: error.message,
        variant: "destructive"
      });
      setIsProcessing(false);
      setProgress(0);
    }
  };

  const pollSunoSeparationStatus = async (separationTaskId: string) => {
    const pollInterval = setInterval(async () => {
      try {
        const { data, error } = await supabase.functions.invoke('get-suno-vocal-separation-info', {
          body: { taskId: separationTaskId }
        });

        if (error) throw error;

        if (data.isCompleted) {
          clearInterval(pollInterval);
          setStems(data.stems);
          setProgress(100);
          setIsProcessing(false);
          
          toast({
            title: "‚úÖ Separation completed",
            description: "All stems are ready for download"
          });
        } else if (data.isFailed) {
          clearInterval(pollInterval);
          setIsProcessing(false);
          setProgress(0);
          
          toast({
            title: "‚ùå Separation failed",
            description: data.errorMessage || "Unknown error occurred",
            variant: "destructive"
          });
        } else {
          // Still processing, update progress
          setProgress(prev => Math.min(prev + 5, 90));
        }
      } catch (error: any) {
        console.error('Status polling error:', error);
        clearInterval(pollInterval);
        setIsProcessing(false);
      }
    }, 5000); // Poll every 5 seconds

    // Cleanup after 10 minutes
    setTimeout(() => {
      clearInterval(pollInterval);
      if (isProcessing) {
        setIsProcessing(false);
        toast({
          title: "‚è∞ Timeout",
          description: "Separation is taking longer than expected. Please try again.",
          variant: "destructive"
        });
      }
    }, 600000);
  };

  const playAudio = (url: string) => {
    if (playingUrl === url) {
      setPlayingUrl(null);
      return;
    }
    setPlayingUrl(url);
  };

  const downloadStem = async (url: string, filename: string) => {
    setDownloadingStems(prev => new Set([...prev, filename]));
    
    try {
      const link = document.createElement('a');
      link.href = url;
      link.download = `${track.title}_${filename}.mp3`;
      link.click();
      
      toast({
        title: "üì• Download started",
        description: `Downloading ${filename} stem`
      });
    } catch (error) {
      toast({
        title: "‚ùå Download failed",
        description: `Failed to download ${filename}`,
        variant: "destructive"
      });
    } finally {
      setDownloadingStems(prev => {
        const newSet = new Set(prev);
        newSet.delete(filename);
        return newSet;
      });
    }
  };

  const downloadAllStems = async () => {
    if (!stems) return;
    
    const stemEntries = Object.entries(stems).filter(([key, url]) => 
      key !== 'original' && url
    );
    
    for (const [key, url] of stemEntries) {
      if (url) {
        await downloadStem(url, key);
        // Small delay between downloads
        await new Promise(resolve => setTimeout(resolve, 500));
      }
    }
  };

  const renderStemPlayer = (url: string | undefined, label: string, filename: string) => {
    if (!url) return null;

    const isDownloading = downloadingStems.has(filename);

    return (
      <div className="flex items-center justify-between p-3 bg-muted/30 rounded-lg border">
        <div className="flex items-center gap-3">
          <Button
            variant="ghost"
            size="sm"
            onClick={() => playAudio(url)}
            className="h-8 w-8 p-0"
          >
            {playingUrl === url ? <Pause className="h-4 w-4" /> : <Play className="h-4 w-4" />}
          </Button>
          <span className="font-medium">{label}</span>
        </div>
        <Button
          variant="outline"
          size="sm"
          onClick={() => downloadStem(url, filename)}
          disabled={isDownloading}
          className="gap-2"
        >
          <Download className="h-4 w-4" />
          {isDownloading ? 'Downloading...' : 'Download'}
        </Button>
      </div>
    );
  };

  const selectedMode = SEPARATION_MODES.find(mode => mode.type === separationType);

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="max-w-3xl max-h-[85vh] overflow-y-auto">
        <DialogHeader>
          <DialogTitle className="flex items-center gap-2">
            <Scissors className="h-5 w-5" />
            Stem Separation Platform
          </DialogTitle>
        </DialogHeader>

        <div className="space-y-6">
          {/* Track Info */}
          <div className="bg-muted/30 p-4 rounded-lg">
            <div className="flex items-center gap-2 mb-2">
              <AudioWaveform className="h-4 w-4" />
              <h3 className="font-semibold">{track.title}</h3>
              <Badge variant={isSunoTrack ? "default" : isMurekaTrack ? "secondary" : "outline"}>
                {track.metadata?.service || 'Unknown'}
              </Badge>
            </div>
            <p className="text-sm text-muted-foreground">
              Separate vocals and instruments using AI-powered source separation
            </p>
          </div>

          {/* Service Support Info */}
          {!isSunoTrack && !isMurekaTrack && (
            <div className="bg-destructive/10 border border-destructive/20 p-4 rounded-lg">
              <p className="text-sm text-destructive">
                ‚ö†Ô∏è Stem separation is currently only available for tracks generated by Suno AI or Mureka AI.
              </p>
            </div>
          )}

          {/* Separation Type Selection */}
          {!isProcessing && !stems && (isSunoTrack || isMurekaTrack) && (
            <div className="space-y-4">
              <div>
                <Label className="text-base font-semibold">Separation Mode</Label>
                {isSunoTrack ? (
                  <RadioGroup 
                    value={separationType} 
                    onValueChange={(value: 'separate_vocal' | 'split_stem') => setSeparationType(value)}
                    className="mt-3 space-y-3"
                  >
                    {SEPARATION_MODES.map((mode) => (
                      <div key={mode.type} className="flex items-start space-x-3 p-3 border rounded-lg hover:bg-muted/30">
                        <RadioGroupItem value={mode.type} id={mode.type} className="mt-1" />
                        <Label htmlFor={mode.type} className="cursor-pointer flex-1">
                          <div>
                            <div className="flex items-center gap-2 mb-1">
                              <span className="font-medium">{mode.label}</span>
                              <Badge variant="outline">{mode.credits} credit{mode.credits > 1 ? 's' : ''}</Badge>
                            </div>
                            <div className="text-sm text-muted-foreground mb-2">
                              {mode.description}
                            </div>
                            <div className="flex flex-wrap gap-1">
                              {mode.stems.map((stem) => (
                                <Badge key={stem} variant="secondary" className="text-xs">
                                  {stem}
                                </Badge>
                              ))}
                            </div>
                          </div>
                        </Label>
                      </div>
                    ))}
                  </RadioGroup>
                ) : (
                  <div className="mt-3 p-3 border rounded-lg bg-muted/30">
                    <div className="font-medium">Mureka Stem Separation</div>
                    <div className="text-sm text-muted-foreground">
                      Automatic separation into available stems
                    </div>
                  </div>
                )}
              </div>

              {/* Selected Mode Info */}
              {selectedMode && isSunoTrack && (
                <div className="bg-primary/5 border border-primary/20 p-4 rounded-lg">
                  <div className="flex items-center gap-2 mb-2">
                    <Music2 className="h-4 w-4" />
                    <span className="font-medium">Selected: {selectedMode.label}</span>
                  </div>
                  <p className="text-sm text-muted-foreground">
                    This will create <strong>{selectedMode.stems.length} stems</strong> and consume <strong>{selectedMode.credits} credit{selectedMode.credits > 1 ? 's' : ''}</strong>
                  </p>
                </div>
              )}

              <Button 
                onClick={handleStartSeparation}
                className="w-full"
                size="lg"
                disabled={!isSunoTrack && !isMurekaTrack}
              >
                <Scissors className="h-4 w-4 mr-2" />
                Start Separation
              </Button>
            </div>
          )}

          {/* Processing State */}
          {isProcessing && (
            <div className="space-y-4">
              <div>
                <div className="flex justify-between items-center mb-2">
                  <span className="font-medium">Processing stems...</span>
                  <span className="text-sm text-muted-foreground">{progress}%</span>
                </div>
                <Progress value={progress} className="w-full" />
              </div>
              <div className="bg-muted/30 p-4 rounded-lg">
                <p className="text-sm text-muted-foreground">
                  üéµ AI is analyzing and separating your track into individual stems. 
                  This process may take several minutes depending on the track complexity.
                </p>
              </div>
            </div>
          )}

          {/* Results */}
          {stems && (
            <div className="space-y-4">
              <div className="flex items-center justify-between">
                <h3 className="font-semibold text-lg flex items-center gap-2">
                  <Music2 className="h-5 w-5" />
                  Separated Stems
                </h3>
                <Button onClick={downloadAllStems} variant="outline" className="gap-2">
                  <Download className="h-4 w-4" />
                  Download All
                </Button>
              </div>

              <div className="grid gap-3">
                {/* Primary stems first */}
                {renderStemPlayer(stems.vocals, "Vocals", "vocals")}
                {renderStemPlayer(stems.instrumental, "Instrumental", "instrumental")}
                
                {/* Secondary stems */}
                {(stems.backingVocals || stems.drums || stems.bass || stems.guitar || 
                  stems.keyboard || stems.percussion || stems.strings || stems.synth || 
                  stems.fx || stems.brass || stems.woodwinds) && (
                  <>
                    <Separator />
                    {renderStemPlayer(stems.backingVocals, "Backing Vocals", "backing_vocals")}
                    {renderStemPlayer(stems.drums, "Drums", "drums")}
                    {renderStemPlayer(stems.bass, "Bass", "bass")}
                    {renderStemPlayer(stems.guitar, "Guitar", "guitar")}
                    {renderStemPlayer(stems.keyboard, "Keyboard", "keyboard")}
                    {renderStemPlayer(stems.percussion, "Percussion", "percussion")}
                    {renderStemPlayer(stems.strings, "Strings", "strings")}
                    {renderStemPlayer(stems.synth, "Synthesizer", "synth")}
                    {renderStemPlayer(stems.brass, "Brass", "brass")}
                    {renderStemPlayer(stems.woodwinds, "Woodwinds", "woodwinds")}
                    {renderStemPlayer(stems.fx, "Effects", "fx")}
                  </>
                )}
              </div>

              <Button 
                onClick={() => {
                  setStems(null);
                  setTaskId(null);
                  setProgress(0);
                }}
                variant="outline"
                className="w-full gap-2"
              >
                <Scissors className="h-4 w-4" />
                Start New Separation
              </Button>
            </div>
          )}
        </div>

        {/* Audio Player */}
        {playingUrl && (
          <audio 
            key={playingUrl}
            src={playingUrl} 
            autoPlay 
            controls 
            className="w-full mt-4"
            onEnded={() => setPlayingUrl(null)}
          />
        )}
      </DialogContent>
    </Dialog>
  );
}